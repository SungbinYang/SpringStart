# 객체지향

## 개발환경 설치

## 객체지향이란?
  1. 객체 지향의 등장
      * 객체지향의 개념은 1970년대에 들어서 용어가 나왔으며 이는 벌써 50년이 넘어가는 역사를 가지고 있습니다.
      * 하지만 이전에는 C언어처럼 실행하고자 하는 순서대로 명령어를 입력해서 실행되는 **"절차지향"** 이 주를 이뤘으며 이런한 방법으로 언어들을 **"절차지향 언어"** 라고 합니다.
      * 이 때에는 프로그램의 단위가 크지 않았으며 대체적으로 **간단한 Logic을 순차적으로 처리하여 결과** 를 얻는데 그쳤지만, 점점 컴퓨터의 발전과 이로 인하여 프로그램의 복잡도가 증가하면서 이에 들어가는 유지보수, 개발기간 등 다양한 부분에서 **비 효울이 발생** 하였습니다.
      * 이런 어려움을 해결하기 위해 선택한 방법이 **"효과적인 개발방식"** 을 채택하게 되었고, 이는 이전에 사용하던 흐름에 따른 개발방식에서 벗어나,
      * 객체지향 특성인 **추상화, 상속, 은닉, 재사용, 인터페이스 등** 여러 곳에서 객체지향으로 개발을 시작
      * 함수의 활용으로도 충분히 좋은 프로그램을 개발할수 있었으나 새로운 시각으로 바라보기 시작하였습니다.
      * 객체지향이란 현실에 존재하는 사물을 있는 그대로 모델링하여 이들의 **행위와 속성을 정의** 하고, 절차적이 아닌 객체가 중심이 되어 실제 사물이 동작하는 방식으로 설계하기 시작하였습니다.
      * 이는 사물에 대해서는 **객체 Object** 라고 부르며, 해당 사물이 **행위를 Method** 로 정의하고 해당사물이 가지는 속성을 **변수 Variable** 라고 정의합니다.
      * 실제 사물을 중심으로 설계를 하기때문에 기존의 절차지향보다는 조금 더 편라하게 설계가 가능해졌다.
      * Java는 1995년 Sun Microsystems 작은 언어를 지향하는 객체지향 언어로 Java를 소개하였다. 이는 당시에 C++과 유사한 언어의 구문을 채택하였으나, C++이 가지고 있는 시스템 레벨 접근, 메모리 직접 할당 및 해제, 포인터등 복잡한 개발방식을 사용하지 않았습니다.
      * 또한 어떠한 운영체제에서도 자바 가상머신만 있으면 독립적으로 실행될수 있도록 설계가 되어 있어서 여러 플랫폼에서 호환성을 제공하는 장점을 가지고 있습니다.
    
   2. 객체 설계하기
      * 객체 == 사물 -- Object
        <img width="1177" alt="스크린샷 2021-08-01 오후 9 33 52" src="https://user-images.githubusercontent.com/18282470/127771001-e25158ee-9619-477d-aed1-266744df3614.png">
      
      <img width="1177" alt="스크린샷 2021-08-01 오후 9 34 32" src="https://user-images.githubusercontent.com/18282470/127771017-57002301-0488-4c60-950d-6a1747e3f36f.png">
      
      * 객체의 3가지 요소
        - 상태 유지 (객체의 상태)
          * 객체는 상태정보를 저장하고 유지되어져야 하며 이러한 속성은 변수로 정의되어져야 한다. 이러한 속성값이 바뀜으로 인하여 객체의 상태가 변경될수 있어야 하낟.
        - 기능 제공 (객체의 책임)
          * 객체는 기능을 제공해야 한다. 이 부분은 Method의 제공으로 이루어진다.
          * 이 부분은 캡슐화와 연관이 있으며 외부로부터 직접 속성에 접근하여 변경하는것이 아닌 객체가 제공하는 Method로 기능이 제공되어져야 한다.
        - 고유 식별자 제공(객체의 유일성)
          * 각각의 객체는 고유한 식별자를 가져야 한다.
          * 예를 들면, 카드번호, 계좌번호, 자동차 번호와 같은 속성을 통해서 각각 고유한 값을 줄 수 있으며, 이는 이후 DB에서 Unique Key, 또는 Primary Key로도 작성이 가능하다.

   3. 물리 객체와 개념 객체
      * 물리 객체
        * 물리 객체는 실제로 사물이 존재하며 이를 클래스로 정의한 객체를 의미한다.
        * ex) 자동차 렌탈 시스템 : 자동차, 고객, 직원, 사업장, 정비소등등
        * ex) 급여관리 시스템: 직원, 월급통장
      * 개념 객체
        * 이후 우리가 개발한 웹 시스템에 Service에 해당되며, 이는 business Logic을 처리하는 부분을 의미한다.
        * Business Logic에서는 여러 객체를 서로 상호작용하도록 하며, 객체가 제공하는 오퍼레이션 Method를 통해서 객체의 속성을 변경시킨다.
        * ex) 사용자 관리 시스템: 사용자 객체의 마지막 접속일자를 이용하여 계정만료, 비밀번호초기화, 재등록 처리 등등
      * 객체 지향에서의 대부분의 코딩은 각 객체에 기능을 정의하고 이를 business logic을 처리하는 service에서 객체의 method를 활용하여 여러가지 조건을 확인하여 객체의 속성을 변경하는 작업이 주된 코딩이다.
      * 이러한 작업을 위해서는 각 객체의 속성, 이러한 속성을 변경하거나 상태를 변경할수 있는 오퍼레이션을 잘 정의해야한다. 

## 객체지향의 4대 특성
  1. 캡슐화
      * 캡슐화는 객체의 속성을 보호하기 위해서 사용합니다.
      * 객체의 캡슐화는 현실세계에서도 볼수 있습니다. 컴퓨터 본체 안에 수 많은 부붐이 있지만, 전원을 켜기위해서는 메인보드에 전기신호를 직접 주는것이 아닌 외부 케이스에 있는 전원버튼을 통해서 상태속성을 On/Off 하도록 변경합니다. 
      * Method 설계
        * 속성이 선언되었으나, 이의 상태를 변경하는 method가 없다면, 잘못 선언된 속성이다. <br /> 즉, 자신이 가지고 있는 속성에 대해서는 해당 상태를 변경하는 기능을 제공해야한다.
        * 실물 객체가 가진 기능을 모두 제공해야 한다. <br /> 예를 들면, 자동차의 렌탈, 반납, 주행거리 계산등등
        * 각각의 method는 서로 관련성이 있어야 한다. <br /> 차량의 렌탈/반납, 자동차 등록증 등록/해지 등 각 속성의 상대 되는 기능을 제공해야한다.
        * 객체 안의 method는 객체 안의 속성을 처리해야 하며, 다른 객체를 전달받아 해당 다른 객체에 정의된 속성을 직접 처리하면 안된다.
        * 단, method에 실행에 필요한 값들은 객체의 형태가 아닌 매개변수의 형태로 전달되어져야 한다.
      * Getter / Setter Method
        * 외부에서 내부속성에 직접 접근 하는것이 아닌 getter/setter method를 통해서 접근하도록 적용
      * CRUD Method
        * 데이터 처리를 위한 기본적인 CRUD Method를 제공
      * Business Logic Method
        * 비즈니스 로직 처리를 위한 Method를 제공
      * 객체의 생명주기 처리 Method
        * 흔히 destory(), disconnect() 등 quit()등 소멸에 대한 method
      * 객체의 영구성 관리 Method
        * 영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서 접근이 불가능하도록 private로 선언하며, <br /> 내부의 다른 method를 통해서 사용되도록 한다.
      * Method의 속성은 반드시 1개에 속할 필요는 없으며, 여러 속성에 해당될수 있다.
      * 장점
        * 객체지향의 패러다임 중 하나의 추상화를 제공한다. <br /> 실제로 method가 어떻게 동작하는지는 외부에서 이해할 필요가 없으며, 이를 단순 호출만으로 해당 기능을 실행 할 수 있고, 이를 통해서 객체단위 프로그램 설계가 가능하다.
        * 재 사용성 향상 <br /> 한 객체에 관련된 속성 및 method는 모두 캡슐화의 형태로 제공됨으로, 객체의 모듈성과 응집도가 높아진다. 이를 통해서 재 사용성이 높아진다.
        * 만일 절차적인 프로그래밍에서 method를 재사용한다면, 함수가 참조하고 있는 전역변수 및 내부에서 호출하는 method가 미치는 영향을 모두 체크해야 하나, 객체의 경우는 단일 객체에만 영향을 주기에 재 사용성이 높다.
        * 앞선 이우로 인하여 유지보수의 효율성이 향상된다.
      * 무결성
          * 보통의 캡슐화 코딩이라고 한다면, 주로 **변수는 private**로 선언하고 **Method를 public**으로 선언하는 형태를 많이 가지게 됩니다.
          * 이는 객체의 무결성을 위함입니다. Getter/Setter를 제외하고는 public method는 입력된 매개변수를 **Validation을 한 후**에 실행하는 것을 기본으로 합니다.
          * Validation을 통하여, 객체의 값을 바꾸거나, 값에 대한 유효성을 가질수 있습니다.
  2. 상속
      * 객체지향에서의 상속은 속성의 상속이 아닌 하위로 냐려갈수록 구체화되는것이다. <br />
      <img width="1158" alt="스크린샷 2021-08-02 오후 10 09 48" src="https://user-images.githubusercontent.com/18282470/127867177-e9952be1-6fcd-4d69-8f20-f61d0aeea8f7.png"> <br />
      <img width="1217" alt="스크린샷 2021-08-02 오후 10 11 44" src="https://user-images.githubusercontent.com/18282470/127867365-341c6a80-b55f-4182-b237-dd8349f57250.png"> <br />
      * 상속의 효과
        * 프로그램 구조에 대한 이해도 향상 <br /> 최상위 클래스의 구조를 보고, 하위클래스의 동작을 이해할수 있다.
        * 재사용성 향상 <br /> 상속을 이용하여, 해당 클래스에 필요한 속성 및 메소드를 모두 정의하지 않고, 상속을 받아서 사용할수 있다.
        * 확장성 향상 <br /> 일관된 형태의 클래스 객체를 추가 할 수 있어, 간단하게 프로그램 확장이 가능하다. ex) 신규 유닛
        * 유지보수성 향상 <br /> 각 객체마다 자신의 메소드를 정의하고 있다면 코드 수정에서 많은 작업이 필요하지만 상속을 사용한 경우 일관된 형태로 작성이 가능하다.
  3. 다형성
        * 다형성은 하나의 개체가 여러개향태로 변화 하는것을 말하며, 이를 객체지향에서도 유사하게 사용을 하고 있습니다.
        * 다형성을 위해서는 오버라이딩을 통해서 가능합니다.
        <img width="1234" alt="스크린샷 2021-08-02 오후 10 22 18" src="https://user-images.githubusercontent.com/18282470/127868644-1dc24347-2eed-4f9b-9273-584de6abc2ff.png"> <br />
        <img width="1236" alt="스크린샷 2021-08-02 오후 10 23 14" src="https://user-images.githubusercontent.com/18282470/127868775-3da1d7d3-3224-41c6-b590-358da38e1631.png">
        ``` java
        Unit 저글링 = new 저글링();
        Unit 시저탱크 = new 시저탱크();
        Unit 레이스 = new 레이스();
        Unit 뮤탈 = new 뮤탈();
        unitMove(저글링);
        unitMove(시저탱크);
        unitMove(레이스);
        unitMove(뮤탈);
        
        private void unitMove(Unit unit) {
          unit.move();
        }
        ```
  4. 추상화
      * 객체지향에서의 추상화는 모델링이다.
      * 구체적으로 공통적인 부분, 또는 특정 특성을 분리해서 재조합하는 부분이 추상화입니다.
      * 앞에서 배운 다형성, 상속 모두 추상화에 속한다.
      <img width="1060" alt="스크린샷 2021-08-02 오후 10 29 54" src="https://user-images.githubusercontent.com/18282470/127869632-5c5f6999-83fe-4c24-a5cf-b5cd4ecd4aae.png">

## 객체지향 설계의 5원칙 SOLID 
  1. 응집도와 결합도
      * 좋은 소프트웨어 설계를 위해서는 **결합도는 낮추고 응집도는 높여야**한다.
      * 결합도 <br /> 모듈(클래스)간의 상호 의존 정도를 나타내는 지표로써 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어서 객체의 재사용 및 유지보수가 유리하다.
      * 응집도 <br /> 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로 <br /> 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져, 재사용성 및 유지보수가 용이하다.
      1. SRP(Single Responsibility Principle) 단일 책임원칙
          * 어떠한 클래스를 변경해야 하는 이유는 한가지뿐이여야 한다.
          <img width="1130" alt="스크린샷 2021-08-02 오후 10 41 00" src="https://user-images.githubusercontent.com/18282470/127871111-4433a033-1a2f-4c84-8642-54586e6e7981.png">
          <img width="1150" alt="스크린샷 2021-08-02 오후 10 42 38" src="https://user-images.githubusercontent.com/18282470/127871317-862e38ba-3818-4256-9cfb-9af04e8d1897.png">
          <img width="1103" alt="스크린샷 2021-08-02 오후 10 43 25" src="https://user-images.githubusercontent.com/18282470/127871422-f9491754-e2f2-49ed-966a-2f9fe830805a.png">
          ``` java
            class Unit {
               private String name; 
               private int speed;
               public void attack(){
               
               }
               public void move(){
                  if(name.equals("저글링")) {
                  speed += 3 
                }else if(name.euqals("탱크")) {
                  if("탱크모드") {
                    speed = 0;
                  } else {
                    speed = 10;
                  }
                } else if(name.equals("정찰기")) {
                  speed = 15;
                  충돌 = false;
                }
             }
          }
         ```
